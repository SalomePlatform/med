//  Copyright (C) 2007-2008  CEA/DEN, EDF R&D, OPEN CASCADE
//
//  Copyright (C) 2003-2007  OPEN CASCADE, EADS/CCR, LIP6, CEA/DEN,
//  CEDRAT, EDF R&D, LEG, PRINCIPIA R&D, BUREAU VERITAS
//
//  This library is free software; you can redistribute it and/or
//  modify it under the terms of the GNU Lesser General Public
//  License as published by the Free Software Foundation; either
//  version 2.1 of the License.
//
//  This library is distributed in the hope that it will be useful,
//  but WITHOUT ANY WARRANTY; without even the implied warranty of
//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//  Lesser General Public License for more details.
//
//  You should have received a copy of the GNU Lesser General Public
//  License along with this library; if not, write to the Free Software
//  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
//
//  See http://www.salome-platform.org/ or email : webmaster.salome@opencascade.com
//

#ifndef MEDMEM_INTERPOLATION_HIGHLEVEL_OBJECTS_HXX

#define MEDMEM_INTERPOLATION_HIGHLEVEL_OBJECTS_HXX
#include "MEDMEM_Connectivity.hxx"
#include "MEDMEM_WrapperConnectivity.hxx"
#include "MEDMEM_dTree.hxx"
#include "MEDMEM_WrapperNodes.hxx"
#include "MEDMEM_WrapperMesh.hxx"
#include "MEDMEM_WrapperCells.hxx"
#include "MEDMEM_Mapping.hxx"

// DECLARATIONS

template <int DIMENSION> class Meta_dTree : public dTree<Wrapper_Noeud<DIMENSION>,Wrapper_Nuage_Noeud<DIMENSION>,DIMENSION>
{
protected :
	Wrapper_Nuage_Noeud<DIMENSION> * nuagetmp;
public :
	Meta_dTree(int nn,double * fullinterlace);
	~Meta_dTree() {if ((etat==DTREE_RACINE)&&(nuagetmp)) delete nuagetmp;}
	inline int trouve_plus_proche_point(double *node);
};

class Meta_Nuage_Maille : public Wrapper_Nuage_Maille<Wrapper_Med_Connectivity>
{
protected :
	Wrapper_Med_Connectivity * connectivite_med;
public :
	Meta_Nuage_Maille(CONNECTIVITY * connmed); 
	Meta_Nuage_Maille():Wrapper_Nuage_Maille<Wrapper_Med_Connectivity>(connectivite_med=new Wrapper_Med_Connectivity) {}
	~Meta_Nuage_Maille() {if (connectivite_med) delete connectivite_med;}
};


typedef Wrapper_Maillage<Meta_Nuage_Maille> Meta_Maillage;

template <int DIMENSION> class Meta_Mapping : public Mapping<Meta_Maillage,Meta_Nuage_Maille,Wrapper_Nuage_Noeud<DIMENSION>,Wrapper_Noeud<DIMENSION>,DIMENSION>
{
protected : 
	Wrapper_Nuage_Noeud<DIMENSION> * wrapping_nuage_source;
	Wrapper_Nuage_Noeud<DIMENSION> * wrapping_nuage_cible;
public :
	Meta_Mapping(Meta_Maillage * mb,double * noeudssource,int ns,double * noeudscible,int nc);
	~Meta_Mapping() {if (wrapping_nuage_source) delete wrapping_nuage_source;if (wrapping_nuage_cible) delete wrapping_nuage_cible;}
	inline int Trouve_Maille_Contenant_Noeud(double * node,int num_maille, int flag_convexe=0);
	double donne_valeur_interpolee_P1(double * node,vector<double> vals);
};

// CODE

template <int DIMENSION> Meta_dTree<DIMENSION>::Meta_dTree(int nn,double * fullinterlace)
:dTree<Wrapper_Noeud<DIMENSION>,Wrapper_Nuage_Noeud<DIMENSION>,DIMENSION>
(nuagetmp=new Wrapper_Nuage_Noeud<DIMENSION>(nn,fullinterlace))
	{
	}

template <int DIMENSION> inline int Meta_dTree<DIMENSION>::trouve_plus_proche_point(double *node)
	{
	static Wrapper_Noeud<DIMENSION> nodetmp;
	nodetmp.positionne(node);
	return dTree<Wrapper_Noeud<DIMENSION>,Wrapper_Nuage_Noeud<DIMENSION>,DIMENSION>::trouve_plus_proche_point(Wrapper_Noeud<DIMENSION>(nodetmp));
	}
	
//*	
Meta_Nuage_Maille::Meta_Nuage_Maille(CONNECTIVITY * conmed):Wrapper_Nuage_Maille<Wrapper_Med_Connectivity>(connectivite_med=new Wrapper_Med_Connectivity(conmed))
	{
	}
//*/

template <int DIMENSION> Meta_Mapping<DIMENSION>::Meta_Mapping(Meta_Maillage * mb,double * noeudssource,int ns,double * noeudscible,int nc)
:Mapping<Meta_Maillage,Meta_Nuage_Maille,Wrapper_Nuage_Noeud<DIMENSION>,Wrapper_Noeud<DIMENSION>,DIMENSION>
(mb,
wrapping_nuage_source=new Wrapper_Nuage_Noeud<DIMENSION>(ns,noeudssource),
wrapping_nuage_cible=new Wrapper_Nuage_Noeud<DIMENSION>(nc,noeudscible))
	{
	}

template <int DIMENSION> inline int Meta_Mapping<DIMENSION>::Trouve_Maille_Contenant_Noeud(double * node,int num_maille,int flag_convexe)
	{
	int interdit=num_maille;
	int max_loop=100;
	int nme=0;
	static Wrapper_Noeud<DIMENSION> nodetmp;
	nodetmp.positionne(node);
	return Mapping<Meta_Maillage,Meta_Nuage_Maille,Wrapper_Nuage_Noeud<DIMENSION>,Wrapper_Noeud<DIMENSION>,DIMENSION>::Trouve_Maille_Contenant_Point_Mth_Co(nodetmp,num_maille,interdit,max_loop,nme,flag_convexe);
	}
template <int DIMENSION> double Meta_Mapping<DIMENSION>::donne_valeur_interpolee_P1(double * node,vector<double> vals)
	{
	int num_maille_contenant=Trouve_Maille_Contenant_Noeud(node,0);
	double valeur_interpol=0;
	vector<double> valeurs=CB->Calcule_Coord_Baryc(num_maille_contenant,node);
	int i;
	int num_som;
	for (i=0;i<valeurs.size();i++) 
		{
		cout<<"Lambda(M):"<<i<<" = "<<valeurs[i]<<endl;
		num_som=mailles_back->DONNE_SOMMET_MAILLE(num_maille_contenant,i);
		valeur_interpol+=vals[num_som]*valeurs[i];
		}
	
	return valeur_interpol;
	}

#endif 
